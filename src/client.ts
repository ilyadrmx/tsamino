import * as Models from "./lib/model.js";
import * as Util from "./lib/util.js";
import * as Const from "./lib/const.js";
// ---
import { Request } from "./lib/request.js";
import { AminoAppsError } from "./lib/errors.js";
import { Socket } from "./socket.js";

/**
 * Class representing AminoApps API client
 * @description Main library class that provides and executes calls to the AminoApps API
 * @property {string | null} deviceId Client's device ID used in "NDCDEVICEID" header
 * @property {string | null} sid Client's session ID used in "NDCAUTH" header
 * @property {number} ndcId Client's NDC used in API path
 * @property {string} userAgent Client's user agent used in "User-Agent" header
 * @property {boolean} debug Debug requests
 * @property {Socket} ws Websocket
 * @property {Request} request Client's request executor and builder
 * @see Request
 * @see Socket
 */
export class Client {
    // Client's device ID used in "NDCDEVICEID" header
    public deviceId: string | null;

    // Client's session ID used in "NDCAUTH" header
    public sid: string | null;

    // Client's NDC used in API path
    public ndcId = 0;

    // Client's user agent used in "User-Agent" header
    public userAgent = Client.USER_AGENT;

    // Debug requests
    public debug = false;

    // Websocket
    public ws: Socket;

    // Client's request executor and builder
    public request: Request;

    // Default user agent
    public static USER_AGENT = "Mozilla/5.0 (Linux; Android 10; SM-G980F Build/QP1A.190711.020; wv)" + " " +
        "AppleWebKit/537.36 (KHTML, like Gecko)" + " " +
        "Version/4.0" + " " +
        "Chrome/78.0.3904.96" + " " +
        "Mobile Safari/537.36";

    /**
     * @param {string | null=} [deviceId=Util.generateDeviceId()]
     * Client's device ID used in "NDCDEVICEID" header. Randomly generated by default
     * @param {boolean=} [debug=false] Debug requests
     */
    constructor(deviceId: string | null = Util.generateDeviceId(), debug: boolean = false) {
        this.deviceId = deviceId;
        this.sid = null;
        this.debug = debug;

        this.request = new Request(this);
    }

    /**
     * Login to account with email
     * @param {string} email Account's email
     * @param {string} password Account's password
     * @return {Promise<Models.LoginResponse>} Account information
     */
    public async loginWithEmail(email: string, password: string): Promise<Models.LoginResponse> {
        const body: Models.LoginWithEmail = {
            email: email,
            secret: "0 " + password,
            clientType: 100,
            deviceID: this.deviceId!,
            action: "normal",
            timestamp: Date.now()
        }

        const response = await this.request.call(
            "/auth/login", {
                method: Request.METHOD_POST,
                ndcId: 0,
                contentType: Request.HeaderValues.CONTENT_TYPE_APPLICATION_JSON,
                data: JSON.stringify(body)
            } as Models.RequestParams
        );

        const textResponse = await response.text();
        const basicResponse: Models.BasicResponse = JSON.parse(textResponse);

        if (basicResponse["api:statuscode"] != Const.StatusCodes.SUCCESS)
            throw new AminoAppsError(
                basicResponse["api:message"] || "No message",
                "Email login error",
                textResponse
            );

        const loginResponse: Models.LoginResponse = JSON.parse(textResponse);

        this.sid = loginResponse.sid;
        this.request = new Request(this);

        return JSON.parse(textResponse);
    }

    /**
     * Set community
     * @param {number} [ndcId=0] Community ID
     * @return {Client} Client with local NDC
     */
    public setNdc(ndcId: number | null = 0) {
        this.ndcId = ndcId;
        this.request = new Request(this);

        return this;
    }

    /**
     * Send chat message
     * @param {Models.MessageParams} messageParams Message params
     * @return {Promise<Models.ChatMessage>} Sent chat message information
     * @see Models.MessageParams
     */
    public async sendMessage(messageParams: Models.MessageParams): Promise<Models.ChatMessage> {
        let body: Models.MessageRequest = {
            type: 0,
            timestamp: Date.now(),
            replyMessageId: null,
            content: null,
            extensions: null
        };

        if (messageParams.replyTo)
            body.replyMessageId = messageParams.replyTo;

        if (messageParams.text)
            body.content = messageParams.text;

        if (messageParams.mentionedArray)
            body.extensions = {
                mentionedArray: messageParams.mentionedArray
            };

        const response = await this.request.call(
            `/chat/thread/${messageParams.threadId}/message`, {
                method: Request.METHOD_POST,
                ndcId: this.ndcId,
                contentType: Request.HeaderValues.CONTENT_TYPE_APPLICATION_JSON,
                data: JSON.stringify(body)
            } as Models.RequestParams
        );

        const textResponse = await response.text();
        const basicResponse: Models.BasicResponse = JSON.parse(textResponse);

        if (basicResponse["api:statuscode"] != Const.StatusCodes.SUCCESS)
            throw new AminoAppsError(
                basicResponse["api:message"] || "No message",
                "Sending message error",
                textResponse
            );

        return JSON.parse(textResponse);
    }

    // noinspection JSUnusedGlobalSymbols
    /** Start listening messages from websocket */
    public startMessageListening() {
        this.ws = new Socket(this);
        this.ws.start();
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Get websocket event callbacks from event names.
     *
     * Available event names are:
     * - textMessage: Messages with **text content** (message type 0)
     * - chatMessage: Every message received from the **chat** (any of the message types)
     * - websocketEvent: **Every** websocket event (chat message, notification, invitation, etc.)
     * @param {string} eventName Name of event to listen
     * @param {Models.SocketCallback} callback Event callback
     */
    public onEvent(eventName: string, callback: Models.SocketCallback) {
        this.ws.on(eventName, callback);
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Register bot command.
     *
     * Bot will react on the message if it starts with **``commandName``**
     * @param {string} commandName
     * @param {Models.SocketCallback} callback
     */
    public command(commandName: string, callback: Models.SocketCallback) {
        this.ws.commands.push({
            command: commandName,
            callback: callback
        });
        this.ws.on(commandName, callback);
    }
}