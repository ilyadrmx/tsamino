<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: client.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as Util from "./lib/util.js";
// ---
import { Request } from "./lib/request.js";
import { Socket } from "./socket.js";
// noinspection JSUnusedGlobalSymbols
/**
 * Class representing AminoApps API client
 * @description Main library class that provides and executes calls to the AminoApps API
 * @property {string | null} deviceId Client's device ID used in "NDCDEVICEID" header
 * @property {string | null} sid Client's session ID used in "NDCAUTH" header
 * @property {number} ndcId Client's NDC used in API path
 * @property {string} userAgent Client's user agent used in "User-Agent" header
 * @property {boolean} debug Debug requests
 * @property {Socket} ws Websocket
 * @property {Request} request Client's request executor and builder
 * @see Request
 * @see Socket
 */
export class Client {
    /**
     * @param {Models.ClientParams} [clientParams] Client parameters
     * @see Models.ClientParams
     */
    constructor(clientParams = {}) {
        // Client's NDC used in API path
        this.ndcId = 0;
        // Client's user agent used in "User-Agent" header
        this.userAgent = Client.USER_AGENT;
        // Debug requests
        this.debug = false;
        this.deviceId = clientParams.deviceId || Util.generateDeviceId();
        this.sid = null;
        this.debug = clientParams.debug || false;
        this.request = new Request(this);
    }
    /*------------------*\
     |                  |
     |    AUTH BLOCK    |
     |                  |
    \*------------------*/
    /**
     * Login to account with email
     * @param {string} email Account's email
     * @param {string} password Account's password
     * @return {Promise&lt;Models.LoginResponse>} Account information
     */
    async loginWithEmail(email, password) {
        const body = {
            email: email,
            secret: "0 " + password,
            clientType: 100,
            deviceID: this.deviceId,
            action: "normal",
            timestamp: Date.now()
        };
        const response = await this.request.call("/auth/login", {
            method: Request.METHOD_POST,
            ndcId: 0,
            contentType: Request.HeaderValues.CONTENT_TYPE_APPLICATION_JSON,
            data: JSON.stringify(body),
            withNot200Error: true,
            not200Text: "Email login error"
        });
        const textResponse = await response.text();
        const loginResponse = JSON.parse(textResponse);
        this.sid = loginResponse.sid;
        this.request = new Request(this);
        this.profile = loginResponse.userProfile;
        this.account = loginResponse.account;
        // Debug
        if (this.debug)
            console.log(`[DEBUG] Logged in (email): ${this.profile.uid}`);
        return JSON.parse(textResponse);
    }
    /**
     * Login with session ID
     * @param {string} sid Session ID
     */
    async loginWithSid(sid) {
        this.sid = sid;
        this.request = new Request(this);
        const sidInfo = Util.decodeSid(sid);
        const profile = await this.getUserProfile(sidInfo["2"]);
        this.profile = profile.userProfile;
        const account = await this.getAccountInfo();
        this.account = account.account;
        // Debug
        if (this.debug)
            console.log(`[DEBUG] Logged in (SID): ${this.profile.uid}`);
    }
    /**
     * Set community
     * @param {number} [ndcId=0] Community ID
     * @return {Client} Client with local NDC
     */
    setNdc(ndcId = 0) {
        this.ndcId = ndcId;
        this.request = new Request(this);
        // Debug
        if (this.debug)
            console.log(`[DEBUG] Set NDC: ${ndcId}`);
        return this;
    }
    /*------------------*\
     |                  |
     |    POST BLOCK    |
     |                  |
    \*------------------*/
    /**
     * Send chat message
     * @param {Models.MessageParams} messageParams Message params
     * @return {Promise&lt;Models.ChatMessage>} Sent chat message information
     * @see Models.MessageParams
     */
    async sendMessage(messageParams) {
        let body = {
            type: 0,
            timestamp: Date.now(),
            replyMessageId: null,
            content: null,
            extensions: null
        };
        if (messageParams.replyTo)
            body.replyMessageId = messageParams.replyTo;
        if (messageParams.text)
            body.content = messageParams.text;
        if (messageParams.mentionedArray)
            body.extensions = {
                mentionedArray: messageParams.mentionedArray
            };
        const response = await this.request.call(`/chat/thread/${messageParams.threadId}/message`, {
            method: Request.METHOD_POST,
            ndcId: this.ndcId,
            contentType: Request.HeaderValues.CONTENT_TYPE_APPLICATION_JSON,
            data: JSON.stringify(body),
            withNot200Error: true,
            not200Text: "Send message error"
        });
        return JSON.parse(await response.text());
    }
    /*-----------------*\
     |                 |
     |    GET BLOCK    |
     |                 |
    \*-----------------*/
    /**
     * Get account info
     * @return {Promise&lt;Models.AccountResponse>} Account info
     */
    async getAccountInfo() {
        const response = await this.request.call(`/account`, {
            method: Request.DEFAULT_METHOD,
            ndcId: this.ndcId,
            withNot200Error: true,
            not200Text: "Get account error"
        });
        return JSON.parse(await response.text());
    }
    /**
     * Get user profile information
     * @param {string} uid User's ID
     * @return {Promise&lt;Models.UserProfileResponse>} User profile
     */
    async getUserProfile(uid) {
        const response = await this.request.call(`/user-profile/${uid}`, {
            method: Request.DEFAULT_METHOD,
            ndcId: this.ndcId,
            withNot200Error: true,
            not200Text: "Get profile error"
        });
        return JSON.parse(await response.text());
    }
    /**
     * Get chat thread information
     * @param {string} threadId ID of the chat thread
     * @return {Promise&lt;Models.ThreadResponse>} Chat thread information
     */
    async getThreadInfo(threadId) {
        const response = await this.request.call(`/chat/thread/${threadId}`, {
            method: Request.DEFAULT_METHOD,
            ndcId: this.ndcId,
            withNot200Error: true,
            not200Text: "Get chat thread info error"
        });
        return JSON.parse(await response.text());
    }
    /**
     * Get chat threads information
     * @param {number} [start=0] Where to start getting chats threads
     * @param {number} [size=100] Size of the returned chat threads list
     * @return {Promise&lt;Models.ThreadResponse>} Chat threads information
     */
    async getThreadsInfo(start = 0, size = 100) {
        const response = await this.request.call(`/chat/thread` +
            `?type=joined-me&amp;start=${start}&amp;size=${size}`, {
            method: Request.DEFAULT_METHOD,
            ndcId: this.ndcId,
            withNot200Error: true,
            not200Text: "Get chat threads info error"
        });
        return JSON.parse(await response.text());
    }
    /*--------------------*\
     |                    |
     |    SOCKET BLOCK    |
     |                    |
    \*--------------------*/
    /** Start listening messages from websocket */
    startMessageListening() {
        this.ws = new Socket(this);
        this.ws.start();
    }
    /**
     * Get websocket event callbacks from event names.
     *
     * Available event names are:
     * - textMessage: Messages with **text content** (message type 0)
     * - chatMessage: Every message received from the **chat** (any of the message types)
     * - websocketEvent: **Every** websocket event (chat message, notification, invitation, etc.)
     * @param {string} eventName Name of event to listen
     * @param {Models.SocketCallback} callback Event callback
     */
    onEvent(eventName, callback) {
        this.ws.on(eventName, callback);
    }
    /**
     * Register bot command.
     *
     * Bot will react on the message if it starts with **``commandName``**
     * @param {string} commandName
     * @param {Models.SocketCallback} callback
     */
    command(commandName, callback) {
        this.ws.commands.push({
            command: commandName,
            callback: callback
        });
        this.ws.on(commandName, callback);
    }
    /** Stop listening messages from websocket */
    stopMessageListening() {
        this.ws.stop();
    }
}
// Default user agent
Client.USER_AGENT = "Mozilla/5.0 (Linux; Android 10; SM-G980F Build/QP1A.190711.020; wv)" + " " +
    "AppleWebKit/537.36 (KHTML, like Gecko)" + " " +
    "Version/4.0" + " " +
    "Chrome/78.0.3904.96" + " " +
    "Mobile Safari/537.36";
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a></li><li><a href="Socket.html">Socket</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Fri Oct 14 2022 13:56:26 GMT+0300 (Восточная Европа, летнее время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
